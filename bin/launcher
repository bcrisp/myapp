#!/usr/bin/env ruby

require "bundler/setup"
require "fileutils"
require "json"
require "open-uri"
require "sinatra"
require "thread"
require "uri"

ROOT = File.expand_path("../..", __FILE__)

def load_properties(properties)
  lines = File.readlines(properties).map { |s| s.strip }.reject { |s| s.empty? or s.start_with?("#") }
  Hash[lines.map { |line|
    k, v = line.split(/\s*=\s*/, 2)
    case v
    when /\A(\d+)\z/
      [k.to_sym, v.to_i]
    when /\A(false|true)\z/i
      [k.to_sym, /\Afalse\z/i !~ v]
    else
      [k.to_sym, v.to_s]
    end
  }]
end

options = {
  environment: (ENV["APP_ENV"] || "development"),
  logging: true,
  dump_errors: true,
}

properties = File.join(ROOT, "config", "config.properties")
if File.file?(properties)
  options = options.merge(load_properties(properties))
end

discovery_uri = options.delete(:discovery_uri)

if master = options.delete(:master)
  application_type = "master"
else
  application_type = "slave"
end

if port = options.delete(:"http.port")
  options[:port] = port
end

if data = options.delete(:"data.dir")
  options[:public_folder] = data
  dir = File.new(data)
  unless dir.flock(File::LOCK_EX | File::LOCK_NB)
    raise("another process is using data.dir=#{data.inspect}")
  end
end

if logs = options.delete(:"logs.dir")
  file = File.new(File.join(logs, "#{application_type}.log"), "a+")
  file.sync = true
  unless file.flock(File::LOCK_EX | File::LOCK_NB)
    raise("another process is using logs.dir=#{logs.inspect}")
  end
  use Rack::CommonLogger, file
end

known_options = [
  :bind,
  :dump_errors,
  :environment,
  :logging,
  :port,
  :public_folder,
  :root,
  :sessions,
  :static,
]

options.each do |k, v|
  if known_options.include?(k)
    set k, v
  else
    STDERR.puts("unknown configuration: #{k}=#{v.inspect}")
    exit(1)
  end
end

FileUtils.mkdir_p(File.join(ROOT, "tmp", "pids"))
File.write(File.join(ROOT, "tmp", "pids", "#{application_type}.pid"), $$.to_s)

get "/type" do
  application_type
end

if master
  $nodes = {}
  $nodes_lock = Mutex.new

  get "/status" do
    JSON.generate({"status": "ok"})
  end

  get "/join" do
    if params["environment"] != options[:environment]
      error 400, "no environment specified"
    end
    $nodes_lock.synchronize do
      $nodes["#{request.ip}:#{params["port"] || options[:port]}"] = Time.new.to_i
    end
    JSON.generate({"join": "ok"})
  end

  get "/leave" do
    if params["environment"] != options[:environment]
      error 400, "no environment specified"
    end
    $nodes_lock.synchronize do
      $nodes["#{request.ip}:#{params["port"] || options[:port]}"] = nil
    end
    JSON.generate({"leave": "ok"})
  end

  get "/nodes" do
    JSON.generate({"nodes": $nodes.select { |k, v| v }.keys})
  end
else
  $status = false

  get "/status" do
    JSON.generate({"status": $status ? "ok" : "ng"})
  end

  get "/join" do
    if discovery_uri
      query = URI.encode_www_form(environment: options[:environment], port: options[:port])
      uri = URI.join(URI.parse(discovery_uri), "join?#{query}")
      join = JSON.parse(open(uri).read())
      if join["join"] == "ok"
        $status = true
        JSON.generate({"join": "ok"})
      else
        error 400, "failed to join"
      end
    else
      error 400, "failed to join"
    end
  end

  Thread.new do
    loop do
      begin
        join = JSON.parse(open(URI.parse("http://#{options[:bind] || "127.0.0.1"}:#{options[:port]}/join")).read)
        if join["join"] == "ok"
          # nop
        end
      rescue
        # nop
      end
      sleep(2)
    end
  end
end
